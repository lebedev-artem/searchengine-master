    private final String text;

    public SnippetGenerator(String text) {
        this.text = text;
    }

    public Map<String, Integer> generatePositionsMap(List<String> words) {
        Map<String, Integer> positionsMap = new HashMap<>();
        List<String> lemmas = words.stream()
                .map(this::lemmatize)
                .flatMap(Collection::stream)
                .distinct()
                .collect(Collectors.toList());
        for (String lemma : lemmas) {
            int index = text.indexOf(lemma);
            if (index != -1) {
                positionsMap.put(lemma, index);
            }
        }
        return positionsMap;
    }

    public List<String> generateSnippets(List<String> words) {
        Map<String, Integer> positionsMap = generatePositionsMap(words);
        List<String> snippets = new ArrayList<>();
        int lastPosition = -1;
        StringBuilder snippetBuilder = new StringBuilder();
        for (String word : words) {
            List<String> lemmas = lemmatize(word);
            for (String lemma : lemmas) {
                Integer position = positionsMap.get(lemma);
                if (position != null && position >= lastPosition) {
                    if (snippetBuilder.length() == 0) {
                        lastPosition = position;
                    }
                    snippetBuilder.append(getSnippetText(position, lemma));
                }
            }
            if (snippetBuilder.length() > 0 && !snippets.contains(snippetBuilder.toString())) {
                snippets.add(snippetBuilder.toString());
                snippetBuilder = new StringBuilder();
            }
        }
        if (snippetBuilder.length() > 0 && !snippets.contains(snippetBuilder.toString())) {
            snippets.add(snippetBuilder.toString());
        }
        return snippets;
    }

    private String getSnippetText(int position, String word) {
        int startIndex = Math.max(0, position - 50);
        int endIndex = Math.min(text.length(), position + word.length() + 50);
        return text.substring(startIndex, endIndex);
    }

    private List<String> lemmatize(String word) {
        // возвращаем список лемм для слова word
        // реализация метода опущена, так как она зависит от используемой библиотеки лемматизации
        return Collections.singletonList(word);
    }

    package searchengine.services.search;

    import lombok.Getter;
    import lombok.NoArgsConstructor;
    import lombok.RequiredArgsConstructor;
    import lombok.Setter;
    import lombok.extern.slf4j.Slf4j;
    import org.apache.lucene.morphology.LuceneMorphology;
    import org.apache.lucene.morphology.russian.RussianLuceneMorphology;
    import org.jetbrains.annotations.NotNull;
    import org.jsoup.Jsoup;
    import org.jsoup.safety.Safelist;
    import org.springframework.stereotype.Component;
    import searchengine.morphology.RussianMorphologyComponent;
    import searchengine.services.lemmatization.LemmaFinder;

    import java.io.IOException;
    import java.util.*;

    @Slf4j
    @Component
    @Getter
    @Setter
    @RequiredArgsConstructor
    public class SnippetGenerator {
    	//	private final LuceneMorphology luceneMorphology = new RussianLuceneMorphology();
    	private final LemmaFinder lemmaFinder;
    	private final Integer SNIPPET_LENGTH = 100;

    	public void setText(String text) {
    		this.text = Jsoup.clean(text, Safelist.simpleText()).replaceAll("[^А-Яа-яЁё\\d\\s]+", "");
    	}

    	private String text;

    	public void setQueryWords(List<String> queryWords) {
    		this.queryWords = queryWords;
    	}

    	private List<String> queryWords;


    	public Map<Integer, String> getWords(String text) {
    		Map<Integer, String> words = new HashMap<>();
    		int pos = 0;
    		int index = text.indexOf(" ");
    		while (index >= 0) {
    			String word = text.substring(pos, index);
    			word = word.replaceAll("\\P{L}+", "");
    			if (!word.isEmpty()) {
    				words.put(pos, word);
    			}
    			pos = index + 1;
    			index = text.indexOf(" ", pos);
    		}
    		String lastWord = text.substring(pos);
    		lastWord = lastWord.replaceAll("\\P{L}+", "");
    		if (!lastWord.isEmpty()) {
    			words.put(pos, lastWord);
    		}
    		return words;
    	}

    	public Map<Integer, Set<String>> getLemmas() {
    		Map<Integer, String> words = getWords(text);
    		Map<Integer, Set<String>> lemmas = new HashMap<>();
    		for (Map.Entry<Integer, String> entry : words.entrySet()) {
    			Set<String> lemmaSet = lemmaFinder.getLemmaSet(entry.getValue());
    			if (!lemmaSet.isEmpty())
    				lemmas.put(entry.getKey(), lemmaSet);
    		}
    		return lemmas;
    	}

    	public Map<Integer, String> getDirtyForms() {
    		Map<Integer, Set<String>> lemmas = getLemmas();
    		Map<Integer, String> dirtyForms = new HashMap<>();
    		for (String queryWord : queryWords) {
    			for (Map.Entry<Integer, Set<String>> entry : lemmas.entrySet()) {
    				if (entry.getValue().contains(queryWord.toLowerCase())) {
    					String word = getWords(text).get(entry.getKey());
    					dirtyForms.put(entry.getKey(), word);
    				}
    			}
    		}
    		return dirtyForms;
    	}

    	public List<String> generateSnippets() {
    		List<String> snippets = new ArrayList<>();

    		Map<Integer, String> dirtyForms = getDirtyForms();
    		List<Integer> sortedPositions = new ArrayList<>(dirtyForms.keySet());
    		Collections.sort(sortedPositions);

    		for (Integer pos : sortedPositions) {
    			String word = dirtyForms.get(pos);
    			int startIndex = pos - SNIPPET_LENGTH / 2;
    			int endIndex = pos + word.length() + SNIPPET_LENGTH / 2;
    			if (startIndex < 0) {
    				endIndex += -startIndex;
    				startIndex = 0;
    			}
    			if (endIndex > text.length()) {
    				startIndex -= endIndex - text.length();
    				endIndex = text.length();
    			}
    			String snippet = text.substring(startIndex, endIndex);
    			snippet = snippet.replaceAll("\\P{L}+", " "); // заменяем все символы, не являющиеся буквами, на пробелы
    			snippets.add(snippet);
    		}

    		return snippets;
    	}
    }
